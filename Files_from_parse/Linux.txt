^^1.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как вызвать терминал (консоль) в Ubuntu/&*/
Для вызова терминала используют комбинацию клавиш Ctrl+Alt+T
Результат:
Окно терминала в котором
valeentin87@valeentin87-VirtualBox:~$ //имя пользователя, имя компьютера, расположение где Вы находитесь
// ~ корневой каталог
^^
--@&--
^^2.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как узнать путь (расположение где мы находимся)/&*/
Набрать в консоли команду pwd
Результат:
Окно терминала в котором отобразиться путь к директории, в которой мы находимся
/home/valeentin87
^^
--@&--

^^3.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Какая директория считаеся корневой/&*/
/home/valeentin87  //является корневой, сокращенно обозначается ~
то есть набрав cd ~   можно быстро перейти в корневую директорию
Результат:
Окно терминала в котором мы будем находиться в корневой директории
valeentin87@valeentin87-VirtualBox:~$
^^
--@&--

^^4.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Какая просмотреть список файлов в текущей директории/&*/
Необходимо набрать в терминале команду ls

Результат:

 newtextfile   newtextfile1   shared   snap   test   test1   Видео   
Документы   Загрузки   Изображения 
  Музыка   Общедоступные  'Рабочий стол'   Шаблоны

Чтобы узнать более подробную информацию о файлах необходимо набрать ls -al

Результат:

drwxr-x--- 17 valeentin87 valeentin87 4096 лют  1 14:28  .
drwxr-xr-x  3 root        root        4096 сту 30 21:26  ..
-rw-------  1 valeentin87 valeentin87  581 сту 31 22:12  .bash_history
-rw-r--r--  1 valeentin87 valeentin87  220 сту 30 21:26  .bash_logout
-rw-r--r--  1 valeentin87 valeentin87 3771 сту 30 21:26  .bashrc
drwx------ 13 valeentin87 valeentin87 4096 сту 31 00:07  .cache

//при этом -a означает, что скрытые файлы и паки (начинаются с . ) тоже отобразятся

^^
--@&--

^^5.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как узнать справку о команде терминала/&*/
Набираем в терминале команду о которой хотим узнать справку и добавляем --help
Например: 
ls --help
Результат:
Использование: ls [ПАРАМЕТР]… [ФАЙЛ]…
Выдаёт информацию о ФАЙЛАХ (по умолчанию о текущем каталоге).
Сортирует в алфавитном порядке, если не задан ни --sort, ни один из
параметров -cftuvSUX.

Аргументы, обязательные для длинных параметров, обязательны и для коротких.
  -a, --all                  не скрывать файлы начинающиеся с .
  -A, --almost-all           не выдавать подразумеваемые . и ..
^^
--@&--

^^6.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как можно осуществлять навигацию (перемещение) между каталогами/&*/
С помощью команды   cd
Например: 
Чтобы переместиться в каталог dir имеющийся в той папке, где мы находимся набираем
cd dir
Если dir находится на другом уровне, то либо поднимаемся на уровень выше с помощью команды
cd ..
Либо используем абсолютный (полный) путь к файлу
cd ~/home1/dir
Результат:
Консоль с отображением того каталога, где мы находимся

^^
--@&--
^^7.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как можно осуществлять навигацию (перемещение) между каталогами/&*/
С помощью команды   cd
Например: 
Чтобы переместиться в каталог dir имеющийся в той папке, где мы находимся набираем
cd dir
Если dir находится на другом уровне, то либо поднимаемся на уровень выше с помощью команды
cd ..
Либо используем абсолютный (полный) путь к файлу
cd ~/home1/dir
Результат:
Консоль с отображением того каталога, где мы находимся

^^
--@&--

^^8.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как можно просмотреть содержимое файла/&*/
С помощью команды cat
Например имеем файл newtextfile в котором фраза "Это новый текстовой файл"
cat newtextfile

Результат:
"Это новый текстовый файл"
valeentin87@valeentin87-VirtualBox:~/testDirectory$

//если файл очень большой то возможно промтотреть только ту часть, которая помещается на 1 экране

^^
--@&--

^^9.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как можно просмотреть большой файл на сервере/&*/
С помощью команды cat и утилиты more
Например имеем файл newtextfile  на сервере, размер которого большой, набираем
cat newtextfile | more

Результат:
отобразится начало файла, далее для построчного перемещения набираем Enter
для полистного перемещения пробел
выход q

Недостаток - нельзя перемещаться вверх по файлу, альтернатива:
утилита less  // позволяет перемещаться по файлу и вверх и вниз, с помощью стрелок курсора

^^
--@&--
^^10.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как создать новую директорию/&*/
С помощью команды mkdir
Например cоздадим директорию dir2:
mkdir dir2

Результат: (отображение в команду ls -al)
drwxrwxr-x  2 valeentin87 valeentin87 4096 лют  2 13:45  dir2
// можно создать сразу несколько каталогов:
mkdir one two three    // такая команда создаст сразу три каталога в текущей директории
Результат:
drwxrwxr-x 2 valeentin87 valeentin87 4096 лют  2 13:49 one
drwxrwxr-x 2 valeentin87 valeentin87 4096 лют  2 13:49 three
drwxrwxr-x 2 valeentin87 valeentin87 4096 лют  2 13:49 two

^^
--@&--

^^11.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как создать дерево каталогов/&*/
С помощью команды mkdir -p
Например в директории dir2 хотим создать dir3/dir4/dir5   :

mkdir -p dir3/dir4/dir5

Результат: (попробуем перейти в директорию dir5)
valeentin87@valeentin87-VirtualBox:~/dir2/dir3/dir4/dir5$

^^
--@&--
^^12.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как создать каталог не в той директории где находишься/&*/
С помощью команды mkdir и абсолютного пути
Например в домашней директории хотим создать папку newdir (находясь в директории dir5):

$ mkdir ~/newdir

Результат: (после применения команды ls -l)
drwxrwxr-x 2 valeentin87 valeentin87 4096 лют  2 14:00  newdir

^^
--@&--
^^13.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Что делает команда touch/&*/
С помощью команды touch создаётся пустой файл с указанным нами именем

touch newfile_one

Результат: (после применения команды ls -l)
-rw-rw-r-- 1 valeentin87 valeentin87    0 лют  2 20:18 newfile_one
// как видим он имеет размер 0 байт
// причём если применить команду touch c уже имеющимся именем, то у уже существующего
файла поменяется время создания (прикосновения)
^^
--@&--
^^14.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как удалить имеющийся файл/&*/
С помощью команды rm указав имя файла:
rm file_name


Результат: 
// из текущей директории удалится файл с именем file_name
// кроме того, можно удалить файл по его абсолютному пути из любой директории
^^
--@&--
^^15.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как удалить всю директорию со всеми файлами/&*/
С помощью команды rm -r  указав имя директории
rm -r directory_name


Результат: 
будет удалена вся директория с имеющимися в ней файлами
^^
--@&--
^^16.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как копировать файлы, директории/&*/
1.Создайте директорию, в ней несколько файлов (one, two, three)
2. Создайте в имеющейся директории ещё одну, чтобы в неё скопировать файлы

valeentin87@valeentin87-VirtualBox:~$ mkdir dir1
valeentin87@valeentin87-VirtualBox:~$ cd dir1
valeentin87@valeentin87-VirtualBox:~/dir1$ touch one two three
valeentin87@valeentin87-VirtualBox:~/dir1$ mkdir dir_copy 

Синтаксис команды копирования:
cp файл_который_копируем файл_в_который_копируем

valeentin87@valeentin87-VirtualBox:~/dir1$ cp one two three dir_copy  //сразу несколько файлов копируем в директорию
valeentin87@valeentin87-VirtualBox:~/dir1$ ls -l dir_copy
итого 0
-rw-rw-r-- 1 valeentin87 valeentin87 0 лют  2 20:41 one
-rw-rw-r-- 1 valeentin87 valeentin87 0 лют  2 20:41 three
-rw-rw-r-- 1 valeentin87 valeentin87 0 лют  2 20:41 two
valeentin87@valeentin87-VirtualBox:~/dir1$

//нужно помнить, что если копируем в имеющийся файл, то он перезаписывается 
Результат: 
будет удалена вся директория с имеющимися в ней файлами
^^
--@&--
^^17.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Какие работают ключи -i -n -u -v команды cp/&*/
ключ -i  //система спросит у вас действительно вы хотите скопировать файл (y/n)
ключ -n  //не перезаписывать существующий файл
ключ -u //копировать только тогда когда исходный файл новее чем файл назначения, или когда файл назначения отсутствует
ключ -v //пояснять что будет сделано
^^
--@&--

^^18.
/&*/---ОС Linux---|Ubuntu --работа в терминале/&*/Какие скопировать директорию полностью с файлами в ней/&*/
Ключ -r //для копирования каталогов/директорий с их содержимым или без
Синтаксис:
cp -r имя_директории куда_копируем_директория (абс. или относительный путь)
Пример:
cp -rv dir_copy dir2   // содержимое директории dir1 будет скопировано в директорию dir2 c визуализацией того что сделано

Результат:
valeentin87@valeentin87-VirtualBox:~/dir1$ cp -rv dir_copy dir2
'dir_copy' -> 'dir2/dir_copy'
'dir_copy/one' -> 'dir2/dir_copy/one'
'dir_copy/two' -> 'dir2/dir_copy/two'
'dir_copy/three' -> 'dir2/dir_copy/three'


^^
--@&--

^^19.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Какие переименовать файл/&*/

Синтаксис:
mv имя_файла новое_имя_файла
Пример:
mv file1 file2   // файл file1 будет переименован в file2

Результат:



^^
--@&--
^^20.
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Какие перемещать файл в другую директорию/&*/

Синтаксис:
mv имя_файла имя_директории_куда_перемещаем/имя_файла  //без переименования
mv имя_файла имя_директории_куда_перемещаем/имя_файла  //с переименованием

Пример:
mv file1 dir2/file1   // файл file1 будет перемещён в директорию dir2 без переименования
mv file1 dir2/file2   // файл file1 будет перемещён в директорию dir2 и переименован в file2

Результат:



^^
--@&--
^^21 .
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Какой общий синтаксис команды find для поиска в текущей директории/&*/

Команда find в стандартном исполнении производит поиск по имени ссылки в текущей ДИРЕКТОРИИ.
Выводит на экран все доступные файлы, директории, ссылки с указанным именем.
Ключ -type - поиск файлов, папок, символьных ссылок по типу. Выведет все доступные
файлы/диреткории/ссылки
Значения:
f - файл
d - директория
l - ссылка
Поиск в текущей директории:
Синтаксис:
find -type d

Пример:
найти все файлы в текущей директории dir1
Результат:

valeentin87@valeentin87-VirtualBox:~/dir1$ find -type f
./two                      // ./ синоним обозначения текущей директории
./file2
./dir_copy/two
./dir_copy/three
./dir_copy/one
./three
./dir2/dir_copy/two
./dir2/dir_copy/three
./dir2/dir_copy/one
./one

^^
--@&--
^^22 .
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Какой общий синтаксис команды find для поиска в конкретной директории/&*/


Выводит на экран все доступные файлы, в указанной (конкретной) директории, ссылки с указанным именем.
Ключ -type - поиск файлов, папок, символьных ссылок по типу. Выведет все доступные
файлы/диреткории/ссылки
Значения:
f - файл
d - директория
l - ссылка
Поиск в указанной директории:
Синтаксис:
find /home/valeentin87 -type d

Пример:
найти все директории в директории ~/newdir
Результат:

valeentin87@valeentin87-VirtualBox:~$ find ~/newdir/ -type d
/home/valeentin87/newdir/



^^
--@&--
^^23 .
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Какой общий синтаксис команды find для поиска по имени/&*/


Выводит на экран все файлы с указанным именем, в указанной (конкретной) директории, ссылки с указанным именем.
Ключ -name- поиск файлов, папок, символьных ссылок по имени. Выведет все доступные
файлы/диреткории/ссылки

Поиск в конкретной директории по имени:
Синтаксис:
find /home/valeentin87  name 'имя_файла'

Поиск в текущей директории по имени:
find name 'имя_файла'

Пример:

Результат:


^^
--@&--
^^24 .
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Какой общий синтаксис команды find для поиска с комбинацией ключей -name и -type/&*/

Возможно использовать как с указанием директории поиска, так и поиском в текущей директории
*   //"подстановочный" знаки последовательности символов. Использует любую из указанной последовательности
символов, включая отсутствие символов

Поиск в конкретной директории по имени:
Синтаксис:

Найти все файлы, которые заканчиваются на .conf :
find /home -type f -name '*.conf'

Пример:

Результат:


^^
--@&--
^^25 .
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Что делает команда echo/&*/


Команда echo принимает аргументы и печатает их на стандартный вывод.
Вывод данных на экран:
Пример:
echo "Hello world"

Результат:
Hello world   //отобразится на экране

Вывод данных перенаправлением вывода в файл:

Пример:
echo "Hello world" > my_file     

Результат:
valeentin87@valeentin87-VirtualBox:~$ cat my_file
hello world       //запишет фразу в файл


^^
--@&--

^^26 .
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как создать символьную ссылку на файл или директорию/&*/


Синтаксис:
ln -s полный_путь_к_файлу имя_ссылки
Пример:
valeentin87@valeentin87-VirtualBox:~/testDirectory$ ln -s /home/valeentin87/testDirectory/newtextfile link_newtextfile

Результат:
lrwxrwxrwx  1 valeentin87 valeentin87   43 лют  3 14:26 link_newtextfile -> /home/valeentin87/testDirectory/newtextfile


^^
--@&--

^^27 .
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как узнать уникальный индекс (inode) файла/&*/


Синтаксис:
ln -id имя_файла
Пример:
valeentin87@valeentin87-VirtualBox:~$ ls -id my_file


Результат:
537843 my_file   // 537843 является inode файла


^^
--@&--
^^28 .
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Как создать жёсткую ссылку на файл/&*/

Жёсткие ссылки создаются только на файлы, на папки нет

Синтаксис:
ln абсолютный_путь_к_файлу имя_ссылки
Пример:
valeentin87@valeentin87-VirtualBox:~$ ln /home/valeentin87/my_file my_file_dublicat


Результат:
-rw-rw-r--  2 valeentin87 valeentin87   12 лют  3 14:15  my_file_dublicat


^^
--@&--
^^29 .
/&*/---ОС Linux---/&*/Ubuntu --работа в терминале/&*/Какие свойства жёстких ссылок Вы можете перечислить/&*/

Жёсткие ссылки создаются только на файлы, на папки нет
Жесткая ссылка это по сути файл дубликат (имеет такой же inode) как файл на который ссылается
Изменения в один файл вносят изменения во все дубликаты
Удаление одного дубликата происходит без удаления других, все изменения в них сохраняются



^^
--@&--
^^30 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Какие типы пользователей Вы знаете, опишите параметры каждого/&*/
Три вида пользователей: суперпользователь (root), обычный пользователь (user), системный пользователь (daemon)
суперпользователь (root):
UID = 0
Home/root
Пароль не всегда
Есть shell
Неограниченные полномочия

обычный пользователь (user):
UID>1000
Home/home/user
Пароль установлен
Есть Shell
Доступ в рамках директории

Системный пользователь (daemon):
1<UID<1000
Home Любая
Пароля нет
Нет Shell
Ограниченный доступ

^^
--@&--

^^31 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Какие параметры пользователей Вы знаете/&*/
Три вида пользователей: суперпользователь (root), обычный пользователь (user), системный пользователь (daemon)
UID - user ID (целое число от 0 до ~65000)	// 1000	
GID - group ID					// 1000
домашняя директория (home)			// /home/{user}
login						// {user}
password					// *****
оболочка (shell)				// /bin/bash


^^
--@&--
^^32 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Где хранятся данные о пользователях/&*/
/etc/passwd - список пользователей
/etc/group  - группы пользователей
/etc/shadow - пароли пользователей


^^
--@&--
^^33 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/просмотрите файл /etc/passwd опишите его/&*/
команда cat /etc/passwd

root:x:0:0:root:/root:/bin/bash			// каждая строчка это отдельный пользователь
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin	// поля отделены двоеточием
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...........
имя_пользователя : пароль : user_id : group_id : полное_имя_пользователя : домашняя директория : адрес_оболочки



^^
--@&--
^^34 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/просмотрите файл /etc/group опишите его/&*/
команда cat /etc/group

root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:syslog,valeentin87
tty:x:5:
disk:x:6:
lp:x:7:
mail:x:8:
news:x:9:
uucp:x:10:
man:x:12:
proxy:x:13:
...........
название группы : пароль : group_id : список_пользователей (для большинства групп он пустой)



^^
--@&--
^^35 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/простмотрите файл с паролями пользователей/&*/
команда sudo cat /etc/shadow    // обратите внимание, что с правами обычного пользователя его постмотреть нельзя

root:!:19387:0:99999:7:::
daemon:*:19213:0:99999:7:::
bin:*:19213:0:99999:7:::
sys:*:19213:0:99999:7:::
sync:*:19213:0:99999:7:::
games:*:19213:0:99999:7:::
man:*:19213:0:99999:7:::
lp:*:19213:0:99999:7:::
valeentin87:dJKt3Pq2geQXI4zRQ26h/2IyBknSB:19387:0:9999    // dJKt3Pq2geQXI4zRQ26h/2IyBknSB - хэш существующего пароля
...........
логин_пользователя : пароль (если * то отсутствует) : свойства_пароля(дата установки, время действия..) 
если перед паролем стоит ! то он заблокирован


^^
--@&--

^^36 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/простмотрите файл с паролями пользователей/&*/
команда sudo cat /etc/shadow    // обратите внимание, что с правами обычного пользователя его постмотреть нельзя

root:!:19387:0:99999:7:::
daemon:*:19213:0:99999:7:::
bin:*:19213:0:99999:7:::
sys:*:19213:0:99999:7:::
sync:*:19213:0:99999:7:::
games:*:19213:0:99999:7:::
man:*:19213:0:99999:7:::
lp:*:19213:0:99999:7:::
valeentin87:dJKt3Pq2geQXI4zRQ26h/2IyBknSB:19387:0:9999    // dJKt3Pq2geQXI4zRQ26h/2IyBknSB - хэш существующего пароля
...........
логин_пользователя : пароль (если * то отсутствует) : свойства_пароля(дата установки, время действия..) 
если перед паролем стоит ! то он заблокирован


^^
--@&--

^^37 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/ак добавить нового пользователя/&*/
Все команды от имени администратора (sudo)

Команда:
	sudo useradd -s /bin/bash -m -d /home/testuser testuser
// -s /bin/bash - установка оболочки для пользователя
// -m -d /home/testuser  - установка домашней директории 
// testuser - логин
Пример:
valeentin87@valeentin87-VirtualBox:~$ sudo useradd -s /bin/bash -m -d /home/testuser testuser
[sudo] пароль для valeentin87:
valeentin87@valeentin87-VirtualBox:~$ tail /etc/passwd
Результат:
......
testuser:x:1001:1001::/home/testuser:/bin/bash
......
// по умолчанию по команде useradd пользователь создается без пароля



^^
--@&--
^^38 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/как добавить нового пользователя с помощью скрипта adduser/&*/
Все команды от имени администратора (sudo)

Команда:
	sudo adduser имя_пользователя
Результат:
Добавляется пользователь «testuser2» ...
Добавляется новая группа «testuser2» (1002) ...
Добавляется новый пользователь «testuser2» (1002) в группу «testuser2» ...
Создаётся домашний каталог «/home/testuser2» ...
Копирование файлов из «/etc/skel» ...
Новый пароль:   //вводим два раза одинаковый пароль, домашний каталог и другую информацию...

Команда:
valeentin87@valeentin87-VirtualBox:~$ tail /etc/passwd
Результат:
....
testuser2:x:1002:1002:гыusertest2,345,656272,2828929:/home/testuser2:/bin/bash
....


^^
--@&--
^^39 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/ак поменять пароль пользователя/&*/
Команда passwd
Для смены своего пароля не требуется sudo


Команда:
	sudo passwd имя_пользователя   //устанавливаем пароль для пользователя

Пример:
	Установить пароль для пользователя testuser
	
Результат:
valeentin87@valeentin87-VirtualBox:~$ sudo passwd testuser
[sudo] пароль для valeentin87:
Попробуйте ещё раз.
[sudo] пароль для valeentin87:
Новый пароль:
Повторите ввод нового пароля:
passwd: пароль успешно обновлён
valeentin87@valeentin87-VirtualBox:~$

теперь если просмотреть файл /etc/shadow/ то убедимся, что пароль назначен
valeentin87@valeentin87-VirtualBox:~$ sudo tail /etc/shadow
.....
testuser:$y$j9T$RB1idXzdR4vIH88eVls8d0$dhSBYVWf2HoXqrytb7ARxCnpsNsxjsMjZCM78BQzqVC:19392:0:99999:7:::
.....

^^
--@&--
 ^^40 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Какие файлы и откуда копируются в домашнюю директорию при создании нового пользователя/&*/
Просмотрим домашнюю дтректорию пользователя testuser

valeentin87@valeentin87-VirtualBox:~$ sudo ls -la /home/testuser
итого 20
drwxr-x--- 2 testuser testuser 4096 лют  4 20:30 .
drwxr-xr-x 5 root     root     4096 лют  4 20:36 ..
-rw-r--r-- 1 testuser testuser  220 сту  6  2022 .bash_logout
-rw-r--r-- 1 testuser testuser 3771 сту  6  2022 .bashrc
-rw-r--r-- 1 testuser testuser  807 сту  6  2022 .profile
 // эти три файла скопированы из директории /etc/skel при создании пользователя, предназначены для задания оболочки

^^
--@&--
^^41 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Модифицируйте пользователя назначте его в дополнительную группу/&*/

Синтаксис:
	sudo usermod -aG название_доп_группы имя_пользователя  // G - обозначает действия с группами

Команда:
	sudo usermod -aG adm testuser

// чтобы проверить в каких группах есть пользователь набираем команду id
Для собственного пользователя просто без sudo
Команда:
	id
Результат:
	uid=1000(valeentin87) gid=1000(valeentin87) группы=1000(valeentin87),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare),999(vboxsf)
//для проверки групп другого пользователя:

Команда:
	sudo id testuser
Результат:
uid=1001(testuser) gid=1001(testuser) группы=1001(testuser),4(adm)

^^
--@&--
^^42 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Модифицируйте пользователя поменяв его основную группу/&*/

Синтаксис:
	sudo usermod -g название_группы_котору_делаем_для_пользователя_основной  

Команда:
	sudo usermod -g www-data testuser

Результат:
valeentin87@valeentin87-VirtualBox:~$ sudo usermod -g www-data testuser
valeentin87@valeentin87-VirtualBox:~$ sudo id testuser
uid=1001(testuser) gid=33(www-data) группы=33(www-data),4(adm)

^^
--@&--
^^43 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Как заблокировать и разблокировать пользователя/&*/

Синтаксис:
	sudo usermod -L имя_пользователя  // Lock
	sudo usermod -U имя_пользователя  // Unlock	

Команда:
	sudo usermod -L testuser
Результат:
valeentin87@valeentin87-VirtualBox:~$ sudo tail /etc/shadow   //просмотрим директорию с паролями пользователей (появился "!")
.....
testuser:!$y$j9T$RB1idXzdR4vIH88eVls8d0$dhSBYVWf2HoXqrytb7ARxCnpsNsxjsMjZCM78BQzqVC:19392:0:99999:7:::
.....

^^
--@&--
^^44 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Как удалить пользователя/&*/

Синтаксис:
	sudo userdl имя_пользователя  // пользователь удаляется, но домашняя директория с файлами остаётся



^^
--@&--
^^45 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Как просмотреть (изменить) параметры пароля пользователя/&*/

Синтаксис:
	sudo chage имя_пользователя  // 

Пример:
	sudo chage testuser

Результат:
	valeentin87@valeentin87-VirtualBox:~$ sudo chage testuser
Изменение информации о сроках действия для testuser
Введите новое значение или нажмите ENTER для выбора значения по умолчанию

        Минимальный срок действия пароля [0]:
        Максимальный срок действия пароля [99999]:
        Последний раз пароль был изменён (ГГГГ-ММ-ДД) [2023-02-04]:
        Предупреждать об истечении срока действия пароля за [7]:
        Деактивировать учётную запись через [-1]:
        Дата истечения срока действия учётной записи (ГГГГ-ММ-ДД) [-1]:

^^
--@&--
^^46 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Как добавить (удалить) группу/&*/

Синтаксис:
	sudo groupadd имя_группы  // добавление группы
	sudo groupdel имя_группы  // удаление группы

Пример:
	sudo groupadd newtestgroup

Результат:
	valeentin87@valeentin87-VirtualBox:~$ sudo cat /etc/group  //просмотрели файл со списком групп
	......
	newtestgroup:x:1003:  // появилась новая группа и ей присвоен id Группы

^^
--@&--
^^47 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Как войти в учётную запись пользователя/&*/
Синтаксис:
	su имя_пользователя  // будет запрошен пароль пользователя
	
Пример:

valeentin87@valeentin87-VirtualBox:~$ su testuser
Пароль:
testuser@valeentin87-VirtualBox:/home/valeentin87$ //как видно, мы зашли, как пользователь testuser
// это можно проверить командной id
Результат:\
uid=1001(testuser) gid=33(www-data) группы=33(www-data),4(adm)
// чтобы выйти из оболочки другого пользователя достаточно набрать exit
Команда: 
	exit

Результат:

valeentin87@valeentin87-VirtualBox:~$

^^
--@&--
^^48 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Как войти в пользователя root/&*/

Синтаксис:
	sudo su  // позволит войти в оболочку пользователя root
	
Пример:
valeentin87@valeentin87-VirtualBox:~$ sudo su

Результат:

[sudo] пароль для valeentin87:
root@valeentin87-VirtualBox:/home/valeentin87#   // как видим, имя пользователя стало root
// проверим командой id 
Результат:
uid=0(root) gid=0(root) группы=0(root)


^^
--@&--
^^49 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/Где находятся настройки sudo (root) и как их помотреть/&*/

Настройки пользователя root (sudo) находятся в файле /etc/sudoers в нём определяется кто может пользоваться правами выполнять команды от имени администратора (sudo....) и какие именно команды
// чтобы в него зайти необходимо набрать команду

Команда:
	sudo visudo   // в результате откроется временный файл sudoers.tmp  в редакторе nano

// далее видим список разрешений для каждого пользователя
root    ALL=(ALL:ALL) ALL     //разрешения для root
%admin ALL=(ALL) ALL	      //разрешения для группы (знак % обозначает группу) admin
%sudo   ALL=(ALL:ALL) ALL     //разрешения для группы sudo		

Синтаксис:
	sudo su  // позволит войти в оболочку пользователя root
	
Пример:
valeentin87@valeentin87-VirtualBox:~$ sudo su

Результат:

[sudo] пароль для valeentin87:
root@valeentin87-VirtualBox:/home/valeentin87#   // как видим, имя пользователя стало root
// проверим командой id 
Результат:
uid=0(root) gid=0(root) группы=0(root)

// если мы сделали изменения с ошибками синтаксиса, программа не даст сохранить файл (будет запрос)


^^
--@&--
^^50 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/ Как поменять имя пользователя и группы для файла/&*/

Синтаксис:
	sudo chown новое_имя_пользователя:новое_имя_группы имя_файла

	
Пример: поменять имя пользователя и группы для файла file_two

-rw-rw-r-- 1 valeentin87 valeentin87 39 лют  5 16:41 file_two

Команда:
valeentin87@valeentin87-VirtualBox:~/testDirectory$ sudo chown testuser:www-data file_two
Результат:

[sudo] пароль для valeentin87:
valeentin87@valeentin87-VirtualBox:~/testDirectory$ ls -l
итого 8
-rw-rw-r-- 1 valeentin87 valeentin87  0 лют  5 16:40 file+one
-rw-rw-r-- 1 testuser    www-data    39 лют  5 16:41 file_two	//имя пользователя и группы поменяны
-rw-rw-r-- 1 valeentin87 valeentin87 12 лют  3 14:34 newtextfile


^^
--@&--
^^51 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/ Как поменять имя пользователя и группы для директории/&*/

Синтаксис:
	sudo chown -R новое_имя_пользователя:новое_имя_группы абсолютный_путь_директории

	
Пример: поменять имя пользователя и группы для директории testDirectory

drwxrwxr-x 2 valeentin87 valeentin87 4096 лют  3 14:31  testDirectory

Команда:
valeentin87@valeentin87-VirtualBox:~$ sudo chown -R testuser:www-data /home/valeentin87/testDirectory
Результат:

[sudo] пароль для valeentin87:
valeentin87@valeentin87-VirtualBox:~$ ls -l
итого 8
.......
drwxrwxr-x 2 testuser    www-data    4096 лют  5 16:41  testDirectory
.......


^^
--@&--
^^52 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/ Как поменять имя группы для файла, директории/&*/

Синтаксис:
	sudo chgrp новое_имя_группы название_файла
	sudo chgrp -R новое_имя_группы абсолютный_путь_директории

	
Пример: поменять имя группы для директории testDirectory

drwxrwxr-x 2 valeentin87 valeentin87 4096 лют  3 14:31  testDirectory

Команда:
valeentin87@valeentin87-VirtualBox:~$ sudo chgrp -R www-data /home/valeentin87/testDirectory

^^
--@&--
^^532 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/ Как классифицируются права доступа для файлов и директорий/&*/

drwxrwxr-x
//первый символ определяет тип файла (файл, директория, линк,....)
//2-4 символы - это права доступа для владельца 
	rwx 
//5-7 символы - это права доступа для участников группы пользователей
	rwx
//8-10 символы - это права доступа для всех остальных пользователей
	r-x

Синтаксис:
	sudo chgrp новое_имя_группы название_файла
	sudo chgrp -R новое_имя_группы абсолютный_путь_директории

	
Пример: поменять имя группы для директории testDirectory

drwxrwxr-x 2 valeentin87 valeentin87 4096 лют  3 14:31  testDirectory

Команда:
valeentin87@valeentin87-VirtualBox:~$ sudo chgrp -R www-data /home/valeentin87/testDirectory

^^
--@&--
^^54 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/ Расшифруйте трёхбитные права типа rwr для файлов и директорий/&*/
для файлов:
	r - можно читать (открывать) файл // "-" нельзя открывать файл
	w - можно изменять (записывать новые данные) в файл // "-" нельзя изменять
	x - можно запускать (исполнять) файл // "-" нельзя запускать (исполнять) файл
для директорий:
	r - можно просматривать содержимое директории // "-" нельзя просматривать содержимое директории
	w - можно добавлять (удалять) файлы из директории // "-" нельзя добавлять (удалять) файлы из директории
	x - можно использовать файлы из директории // "-" нельзя использовать файлы из директории
	

^^
--@&--
^^55 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/ Расшифруйте специальные биты доступа/&*/
-rwsr-sr-t
// для владельца s  SUID 4000 - для исполняемых файлов, запуск программы от имени владельца файла
// для группы пользователей s   SGID 2000 - для директорий, создание файлов с группой, назначенной для директории
// для всех остальных  t Sticky bit 1000 - для директорий, удаление файлов только владельцем файла или директории

^^
--@&--
^^56 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/ Опишите общий синтаксис изменения прав доступа/&*/
chmod -R testdir  // изменение прав доступа для всех файлов директории
chmod u=rwx, g=rx, o=r testfile   //символьная форма
chmod 751 testfile   //числовая форма
chmod a+x  //изменение для всех
chmod 4755  // изменение специальных битов


^^
--@&--

^^57 .
/&*/---ОС Linux---/&*/Ubuntu --Права доступа и пользователи/&*/ Измените права доступа на отдельный файл в директории/&*/
Синтаксис:
	chmod u=rwx, g=rx, o=r testfile  //
Пример: изменить права доступа на newtextfile в директории testDirectory
	
Команда:
	valeentin87@valeentin87-VirtualBox:~/testDirectory$ sudo chmod u=rwx,g=rwx,o=rw newtextfile
Результат:
	-rwxrwxrw-  1 testuser    www-data      12 лют  3 14:34 newtextfile
	
^^
--@&--

^^58 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Репозитории/&*/ Пакеетные менеджеры/&*/
1. Тип пакета - формат, в который мы упаковываем наши файлы:
	пакеты типа deb; (пакетный менеджер apt (внутри себя испозьзует принципы менеджера dpkg)   И  dpkg)
	пакеты типа snap;
snap пакеты они независимы (изолирован, как контейннер) от того, в каком дистрибутиве мы устаналиваем пакет, библиотеки, зависимости и всё необходимое у него внутри себя
deb пакет должен знать с каким дистрибутивом, в какой системе, в какой версии работает, какие библиотеки необходимо подгрузить



^^
--@&--

^^59 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Репозитории/&*/ Классификация репозиториев/&*/
По разработчику (степень доверия уменьшается от стандартных до неофициальных):
- стандартные;
- дополнительные;
- неофициальные;

По лицензированию:
main - открытое с поддерджкой;
restricted - проприетарное с поддержкой;
universe - открыто без поддержки
multiverse - прориетарное без поддержки

По версиям ПО:
$release
$release-security //обновление безопасности
$release-updates  //обновление пакета
$release-backports //более свежие версии




^^
--@&--
^^60 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Репозитории/&*/ Где находится файл с конфигурацией репозитория.Как добавить файл в репозиторий/&*/
конфигурация репозитория находится в директории /etc/apt/sources.list   //в этом файле отображается какие базовые репозитории установлены в системе
/etc/apt/sources.list.d/*.list   - добавление файла с адресом репозитория


^^
--@&--

^^61 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Репозитории/&*/ Как записывается название репозитория/&*/

deb http://адрес репозитория   версия_дистрибутива  название_ветки

Например:
deb http://nginx.org/package/ubuntu jzmmy nginx


^^
--@&--

^^62 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Репозитории/&*/ Как производится добавление ключа репозитория/&*/

sudo apt-key add repo.key

Делается это с целью: 


^^
--@&--
^^63 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Утилита apt/&*/ Для чего предназначена утилита apt. Поиск пакета по названию/&*/

Утилита apt предназначена для автоматизированного управления пакетами с учётом зависимостей и работы  с удалёнными репозиториями

apt search package_name      -  поиск пакета по названию и описанию
apt list package_name        -  поиск пакета по имени


^^
--@&--
^^64 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Утилита apt/&*/ Что делают команды show, install, remove, purge в утилите apt/&*/

apt show package_name    -    посмотреть информацию о пакете
apt install package_name -y  -  установить пакет
apt remove package_name      -  удалить пакет, при этои остаются файлы с настройками
apt purge package_name       -  полностью удалить пакет, включая конфигурационные файлы

^^
--@&--
^^65 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Утилита apt/&*/ Что делают команды upgrade, update в утилите apt/&*/

apt upgrade    -     обновить все установленные пакеты
apt upgrate    -     обновить информацию о пакетах в репозиториях, указанных в настройках

^^
--@&--
^^66 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Утилита dpkg/&*/ Перечислите основные команды утилиты dpkg /&*/

утилита dpkg   предназначена для ручного управления пакетами, не работает с зависимостями

dpkg -l    -     просмотр списка пакетов
dpkg -i package_name    -     установить пакет или группу пакетов
dpkg -r package_name    -     удалить пакет или группу пакетов

^^
--@&--
^^67 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Утилита dpkg/&*/ скачайте пакет с сайта VirtualBox.org и установите его с помощью dpkg /&*/
1. заходим на сайт www.virtualbox.org в раздел downloads ищем версию ubunta 22.04 копируем адресс ссылки на скачиваемый пакет.
2. в терминале набираем команду 
			wget адрес_ссылки
получаем в итоге скачанный локально пакет
допустим virtualbox-7.0_7.0.6-155176~Ubuntu~jammy_amd64.deb
выполняем команду 
		dpkg -i virtualbox-7.0_7.0.6-155176~Ubuntu~jammy_amd64.deb

dpkg: зависимости пакетов не позволяют настроить пакет virtualbox-7.0:
При обработке следующих пакетов произошли ошибки:
virtualbox-7.0    // так назывваемый "сломаный пакет"

команда 
		apt -f install  //позволяет восстановить зависимости и устранить все проблемы

^^
--@&--
^^68 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Пакеты snap/&*/ Какие отличительные особенности пакетов snap /&*/
- все зависимости  - в пакете;
- пакет изолирован от системы - разрешения;
- программы запускаются дольше;
- больше потребление ресурсов;
- нет проблем совместимости.

^^
--@&--
^^69 .
/&*/---ОС Linux---/&*/Ubuntu --Установщики пакетов. Пакеты snap/&*/ Перечислите основной синтаксис пакетов snap /&*/
snap search package_name    -  поиск пакета
snap install package_name   -  установка пакета
snap refresh package_name   -  обновление пакета
snap remove  package_name   -  удаление пакета
snap list                   -  просмотр установленных пакетов

^^
--@&--
^^70 .
/&*/---ОС Linux---/&*/Ubuntu --Планировщик задач cron/&*/ Для чего cron предназначен и хде хранится список системных и пользовательских задач /&*/
Планировщик cron (системный планировщик) предназначен для:
	- выполнения регулярных задач по расписанию
	- автоматизации обслуживания системы или приложений
Системные задачи хранятся: (как правило, могут запускаться от любого пользователя как правило администратора (root)
	/etc/crontab
	/etc/cron.d/*
Пользовательские задачи: (доступ конкретными пользователям)
	/var/spool/cron/*
	управление: утилита crontab
^^
--@&--
^^71 .
/&*/---ОС Linux---/&*/Ubuntu --Планировщик задач cron/&*/ В каком формате осуществляется хранение задач в cron /&*/
17 **** root  cd / && run-parts  --report  /etc/cron.hourly
1) 17 ****    // Расписание (минуты, часы, день месяца, месяц, день недели)
2) root       // Пользователь (для выполнения команды)
3) cd / && run-parts  --report  /etc/cron.hourly    //команда для выполнения задачи
 Нужно учитывать, что команда должна выполниться без участия человека (не требовать ответа на вопросы, не требовать ввода текста)

^^
--@&--
^^72 .
/&*/---ОС Linux---/&*/Ubuntu --Планировщик задач cron/&*/ Как можно просмотреть структу файла планировщика /&*/
1. стать рутом
2. Выполнить команду: cat /etc/crontab
Результат:

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly
25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
#
 //hourly -- структура ежечасных задач
 //daily  -- структура ежедневных задач
 //weekly -- структура еженедельных задач
 //monthly-- структура ежемесячных задач 				

^^
--@&--
^^73 .
/&*/---ОС Linux---/&*/Ubuntu --Планировщик задач cron/&*/ как посмотреть список ежедневных задач /&*/

необходимо выполнить команду:

ls /etc/cron.daily	
 
// для остальных типов задач (ежемесячные, ежечасные, еженедельные все по аналогии)			

^^
--@&--
^^74 .
/&*/---ОС Linux---/&*/Ubuntu --Планировщик задач cron/&*/ что хранится в файле /etc/cron.d /&*/

в указанной директории хранятся файлы с дополнительными файлами планировщика (чтобы не засорять crontab)
root@valeentin87-VirtualBox:/etc/cron.daily# cd /etc/cron.d
root@valeentin87-VirtualBox:/etc/cron.d# ls -la
итого 28
drwxr-xr-x   2 root root  4096 сту 30 21:27 .
drwxr-xr-x 133 root root 12288 лют  9 09:09 ..
-rw-r--r--   1 root root   219 кас  9  2021 anacron
-rw-r--r--   1 root root   201 сту  8  2022 e2scrub_all
-rw-r--r--   1 root root   102 сак 23  2022 .placeholder
root@valeentin87-VirtualBox:/etc/cron.d# cat e2scrub_all
30 3 * * 0 root test -e /run/systemd/system || SERVICE_MODE=1 /usr/lib/x86_64-linux-gnu/e2fsprogs/e2scrub_all_cron
10 3 * * * root test -e /run/systemd/system || SERVICE_MODE=1 /sbin/e2scrub_all -A -r
root@valeentin87-VirtualBox:/etc/cron.d#		

^^
--@&--
^^75 .
/&*/---ОС Linux---/&*/Ubuntu --Утилита crontab/&*/ для чего предназначена утилита crontab и каков её основной синтаксис /&*/

утилита crontab предназначена для планирования по расписанию исполнения задач пользователем

crontab -l   //вывести содержимое текущего файла расписания
crontab -r   //удаление текущего файла расписания
crontab -e   //редактирование текущего файла расписания
sudo crontab -u  username   //работа с файлом расписания другого пользователя	

^^
--@&--
^^76 .
/&*/---ОС Linux---/&*/Ubuntu --Утилита crontab/&*/ как создать свой новый файл расписания crontab /&*/

набираем команду 
		crontab -e
получаем запрос на выбор редактора, в котором будем создавать файл
после чего получаем открытый файл с инструкцией
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

далее сохраняем и можем через команду
	crontab -l   //смотреть его содержимое
^^
--@&--
^^77 .
/&*/---ОС Linux---/&*/Ubuntu --Сетевые возможности Linux/&*/ как посмотреть список интерфейсов в системе и их настройки /&*/
команда:
ip a
результат:
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:a6:4f:fd brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic noprefixroute enp0s3
       valid_lft 86035sec preferred_lft 86035sec
    inet6 fe80::6a85:d1f5:bfec:95e0/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default
    link/ether 02:42:a7:7e:ea:4f brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
# lo   - локальный интерфейс, который не выходит за рамки нашего компьютера
# для интерфейса lo (LOOPBACK) данные перемещаются внутри одного компьютера
# UP  - интерфейс работает
# LOWER_UP  -грубо говоря "кабель воткнут"
#  link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00   - это настройки уровня L2
# 08:00:27:a6:4f:fd   - mac адрес сетевого адаптера
# ff:ff:ff:ff:ff:ff   - настройки широковещательных пакетов
# inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic noprefixroute enp0s3 - настройки ip уровня
# 10.0.2.15/24   - ip адрес нашего компьютера с маской подсети (10.0.2 - номер сети 15  - номер хоста)
# fe80::6a85:d1f5:bfec:95e0/64  - IPv6 адрес 
^^
--@&--
^^70 .
/&*/---ОС Linux---/&*/Ubuntu --Сетевые возможности Linux/&*/ как посмотреть список интерфейсов в системе со статистикой /&*/

команда:
ip -s a
результат:
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
    RX:  bytes packets errors dropped  missed   mcast
          4183      39      0       0       0       0
    TX:  bytes packets errors dropped carrier collsns
          4183      39      0       0       0       0

#  bytes packets errors  - показывает сколько было передано пакетов, низкоуровневые ошибки

2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:a6:4f:fd brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic noprefixroute enp0s3
       valid_lft 85967sec preferred_lft 85967sec
    inet6 fe80::6a85:d1f5:bfec:95e0/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
    RX:  bytes packets errors dropped  missed   mcast
         13396     135      0       0       0       0
    TX:  bytes packets errors dropped carrier collsns
         22997     159      0       0       0       0
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default
    link/ether 02:42:a7:7e:ea:4f brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    RX:  bytes packets errors dropped  missed   mcast
             0       0      0       0       0       0
    TX:  bytes packets errors dropped carrier collsns
             0       0      0       0       0       0
^^
--@&--
^^78 .
/&*/---ОС Linux---/&*/Ubuntu --Сетевые возможности Linux/&*/ как посмотреть данные по конкретному интерфейсу /&*/

синтаксис:
ip a show название_интерфейса
команда:
ip a show enp0s3

результат:
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:a6:4f:fd brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic noprefixroute enp0s3
       valid_lft 85711sec preferred_lft 85711sec
    inet6 fe80::6a85:d1f5:bfec:95e0/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
^^
--@&--
^^79 .
/&*/---ОС Linux---/&*/Ubuntu --Сетевые возможности Linux/&*/ как просмотреть информацию о маршрутах /&*/

команда:
ip r
результат:
default via 10.0.2.2 dev enp0s3 proto dhcp metric 100
10.0.2.0/24 dev enp0s3 proto kernel scope link src 10.0.2.15 metric 100
169.254.0.0/16 dev enp0s3 scope link metric 1000
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
# default  - самый главный маршрут (по нему отправляем пакеты за пределы нашего компьютера)
# может называться default getway, его адрес 10.0.2.2
# 10.0.2.0/24 dev enp0s3 proto kernel scope link src 10.0.2.15 metric 100   - наш локальный маршрут, он доступен без маршрутизатора
# позволяет "ходить внутри локальной сети"
# metric 100 - стоимость сети (чем меньше, тем лучше)
^^
--@&--
^80 .
/&*/---ОС Linux---/&*/Ubuntu --Сетевые возможности Linux/&*/ как добавить подсветку при просмотре интерфейсов /&*/

команда:
ip -с a
# названия интерфейсов будут подсвечены цветом
^^
--@&--
^81 .
/&*/---ОС Linux---/&*/Ubuntu --Сетевые возможности Linux/&*/ что такое сокет, как можно посмотреть список доступных сокетов /&*/
сокет это сочетание IP адреса и порта для конкретного протокола
команда:
ss -socket stat

команда ss -ntlp - TCP-сокеты в состоянии LISTEN
# "n" - показать всё в состоянии номеров
# "t" - протокол TCP
# "l" - LISTEN (те, которые работают)
# "p" - показать программы, которые привязаны к этому сокету
^^
--@&--
^82 .
/&*/---ОС Linux---/&*/Ubuntu --Сетевые возможности Linux/&*/ чем отличается команда ss -ntlp  От ss -ntulp /&*/
сокет это сочетание IP адреса и порта для конкретного протокола
команда:
ss -ntulp  # добавляет еще UDP - сокеты


^^
--@&--
^83 .
/&*/---ОС Linux---/&*/Ubuntu --Сетевые возможности Linux/&*/ как просмотреть все установенные сокеты /&*/
сокет это сочетание IP адреса и порта для конкретного протокола
команда:
ss -tulpan   # dct TCP и UDP сокеты


^^
--@&--
^84 .
/&*/---ОС Linux---/&*/Ubuntu --Сетевые возможности Linux/&*/ как просмотреть список программ, которые слушают наши сокеты /&*/
сокет это сочетание IP адреса и порта для конкретного протокола
выполняем тоже самое, что и для просмотра сокетов, только с командой sudo

команда:
sudo ss -tulpan   # можно просто sudo !! (выполнит предыдущую команду с правами администратора)
результат:
Netid       State        Recv-Q       Send-Q                 Local Address:Port                Peer Address:Port        Process
udp         UNCONN       0            0                            0.0.0.0:50770                    0.0.0.0:*            users:(("avahi-daemon",pid=663,fd=14))
udp         UNCONN       0            0                            0.0.0.0:631                      0.0.0.0:*            users:(("cups-browsed",pid=850,fd=7))
udp         UNCONN       0            0                      127.0.0.53%lo:53                       0.0.0.0:*            users:(("systemd-resolve",pid=573,fd=13))
udp         ESTAB        0            0                   10.0.2.15%enp0s3:68                      10.0.2.2:67           users:(("NetworkManager",pid=667,fd=25))
udp         UNCONN       0            0                            0.0.0.0:5353                     0.0.0.0:*            users:(("avahi-daemon",pid=663,fd=12))
udp         UNCONN       0            0                               [::]:52921                       [::]:*            users:(("avahi-daemon",pid=663,fd=15))
udp         UNCONN       0            0                               [::]:5353                        [::]:*            users:(("avahi-daemon",pid=663,fd=13))
tcp         LISTEN       0            70                         127.0.0.1:33060                    0.0.0.0:*            users:(("mysqld",pid=898,fd=21))
tcp         LISTEN       0            151                        127.0.0.1:3306                     0.0.0.0:*            users:(("mysqld",pid=898,fd=23))
tcp         LISTEN       0            511                          0.0.0.0:80                       0.0.0.0:*            users:(("nginx",pid=872,fd=6),("nginx",pid=871,fd=6),("nginx",pid=870,fd=6),("nginx",pid=869,fd=6),("nginx",pid=868,fd=6))
tcp         LISTEN       0            4096                   127.0.0.53%lo:53                       0.0.0.0:*            users:(("systemd-resolve",pid=573,fd=14))
tcp         LISTEN       0            128                          0.0.0.0:22                       0.0.0.0:*            users:(("sshd",pid=803,fd=3))
tcp         LISTEN       0            128                        127.0.0.1:631                      0.0.0.0:*            users:(("cupsd",pid=764,fd=7))
tcp         ESTAB        0            0                          10.0.2.15:22                      10.0.2.2:50738        users:(("sshd",pid=2654,fd=4),("sshd",pid=2575,fd=4))
tcp         LISTEN       0            128                             [::]:22                          [::]:*            users:(("sshd",pid=803,fd=4))
tcp         LISTEN       0            128                            [::1]:631                         [::]:*            users:(("cupsd",pid=764,fd=6))

^^
--@&--
^85 .
/&*/---ОС Linux---/&*/Ubuntu --Конфигурация сети в Ubuntu/&*/ в какой директории находятся конфигурационные файлы подключения по сети/&*/
конфигурационные файлы подключения по сети находятся в директории
/etc/netplan/*.yaml

при изменении этих файлов, чтобы изменения вступили в силу необходимо набрать команду
команда:
	netplan try # при этом если мы изменили конфиг файл ошибочно, то даётсф 2 минуты чтобы нажать Enter если этого не сделать то КОНФИГ файл откатится к предыдущей версии
при этом чтобы принудительно применить конфигурацию необходимо набрать команду:
	netplan apply

^^
--@&--
^86 .
/&*/---ОС Linux---/&*/Ubuntu --Конфигурация сети в Ubuntu/&*/ как просмотреть конфигурационный файл по умолчанию и что он означает/&*/
конфигурационный файл по умолчанию находится в директории /etc/netplan
называется 01-network-manager-all.yaml
и содержит следующую информацию:
network:
  version: 2
  renderer: NetworkManager  # указывает, что его настройка осуществляется через NetworkManager

^^
--@&--
^87 .
/&*/---ОС Linux---/&*/Ubuntu --Конфигурация сети в Ubuntu/&*/ имеет ли значение количество отступов в файлах типа *.yaml/&*/
каждый уровень в файлах типа *.yaml имеет определенное количество отступов от начала строки (2 пробела для каждого нового уровня)

^^
--@&--
^88 .
/&*/---ОС Linux---/&*/Ubuntu --Конфигурация сети в Ubuntu/&*/ как осуществляется настройка netplan конфигурации с DHCP/&*/
настройка осуществляется следующим содержимым файла (для динамической конфигурации):
network:
  version: 2
	renderer: networkd # используется для настройки сетей в серверной форме ubuntu
	ethernets:
	  enp0s3: # название основного интерфейса в нашей виртуальной машине
	    dhcp4: yes # для IPv4 мы получим IP адрес автоматически из DHCP
	    nameservers:  
	      addresses:  # далее указывается список DNS серверов, которые Вам нужны
	        - 8.8.8.8 
		- 8.8.4.4
^^
--@&--
^89 .
/&*/---ОС Linux---/&*/Ubuntu --Конфигурация сети в Ubuntu/&*/ как будет выглядеть настройка netplan для статической конфигурации/&*/
настройка осуществляется следующим содержимым файла (для динамической конфигурации):
# для статической конфигурации IPv4 адрес автоматически назначаться не будет
# поэтому "dhcp4" будет иметь флаг "no"

network:
  version: 2
	renderer: networkd # используется для настройки сетей в серверной форме ubuntu
	ethernets:
	  enp0s3: # название основного интерфейса в нашей виртуальной машине
	    dhcp4: no
	    addresses: [192.168.0.8/24]  #перечисляется список IP адресов для нашего интерфейса (можно использовать несколько, тогда они указываются через запятую)
	    gateway4: 192.168.0.1  #указывает, что наш шлюз default (по умолчанию) будет иметь такой адрес (сможем выходить во внешние сети через этот маршрутизатор)
	    nameservers:  
	      addresses:  # далее указывается список DNS серверов, которые Вам нужны
	        - 8.8.8.8 
		- 8.8.4.4
^^
--@&--
^90 .
/&*/---ОС Linux---/&*/Ubuntu --Диагностика сети/&*/ как провести базовую диагностику сетевой связанности/&*/
используется утилита ping
варианты команд:
	ping 8.8.8.8  # для проверки связи доступности хоста по IP адресу
	ping ya.ru    # для проверки доступности по доменному имени
команда:
	ping ya.ru
результат:
PING ya.ru (77.88.55.242) 56(84) bytes of data.
64 bytes from ya.ru (77.88.55.242): icmp_seq=1 ttl=244 time=40.0 ms
64 bytes from ya.ru (77.88.55.242): icmp_seq=2 ttl=244 time=39.7 ms
64 bytes from ya.ru (77.88.55.242): icmp_seq=3 ttl=244 time=40.2 ms
^C
--- ya.ru ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2005ms  # 3 пакета отправлено, 3 получено 0 потеряно за такое-то время
rtt min/avg/max/mdev = 39.659/39.972/40.238/0.238 ms	

^^
--@&--
^91 .
/&*/---ОС Linux---/&*/Ubuntu --Диагностика сети/&*/ как работает команда host/&*/
команда:
	host -t a yandex.ru   # проверка DNS выдаст ip адрес соответствующий доменному имени
	host -t a yandex.ru 8.8.8.8   - # другой DNS-сервер
	dig @8.8.8.8 goodle.com   # подробная информация по DNS
команда:
	host -t a ya.ru
результат:
ya.ru has address 5.255.255.242
ya.ru has address 77.88.55.242
^^
--@&--
^92 .
/&*/---ОС Linux---/&*/Ubuntu --Диагностика сети/&*/как провести тестирование сети по маршруту прохождения/&*/
команда:
	tracepath ya.ru  # просмотр маршрута прохождения пакетов (установлена по умолчанию)
	traceroute ya.ru # необходимо её дополнительно устанавливать
	mtr ya.ru	# постоянный мониторинг проходимости пакетов
команда:
	tracepath ya.ru
результат:
 1?: [LOCALHOST]                      pmtu 1500
 1:  10.0.2.2                                              0.165ms
 1:  10.0.2.2                                              0.144ms
 2:  10.0.2.2                                              4.513ms reached
^^
--@&--
^93 .
/&*/---ОС Linux---/&*/Ubuntu --Диагностика сети/&*/ как принудительно назначить IP адресу доменное имя/&*/
необходимо зайти в файл /etc/hosts и прописать требуемоемое соответствие
например 
127.0.0.1   localhost   # приэтом этот файл будет иметь преимущество над стандартным IP указанного хоста
^^
--@&--
^94 .
/&*/---ОС Linux---/&*/Ubuntu -- фильтрация пакетов/&*/ перечислите основные команды фильтрации пакетов в утилите iptables/&*/
iptables -L -nv  # показать список всех правил в числовом виде (по умолчанию список выдается для таблицы filter
iptables -L -nv -t nat  # указывает список правил для конкретной таблицы (например nat)
iptables -P INPUT DROP  # выкидывает все пакеты, которые не попали под наши правила # политика по умолчанию

# ниже представлено добавление правил:
iptables -А INPUT -p tcp --dport 80 -j ACCEPT   # разрешить входящий трафик по TCP протоколу на порт 80
# порт назначения (dport 80) как раз будет для нас точкой входа принимаемого пакета
# для входящего трафика указываем dport (distanation port), для исходящего трафика sport (source port)
 iptables -I INPUT -p tcp --dport 80 -j ACCEPT  #добавляет указанное правило в начало таблицы, а не дописывает в конец (A - append, I - insert)

iptables -A INPUT -p tcp -s 192.168.0.100 --dport 80 -j ACCEPT  # запрещает для конкретного адреса трафик по tcp протоколу на порт 80
# приоритет правил идет сверху вниз (если выполняется правило которое сверху, те, которые ниже уже не проверяются

^^
--@&--
^95 .
/&*/---ОС Linux---/&*/Ubuntu -- фильтрация пакетов/&*/как можно удалять правила из таблиц/&*/
существует 2 варианта:
удаление по номеру правила из таблицы:
	iptables -D INPUT 3
удаление по формулировке самого правила
	iptables -D INPUT -p tcp --dropt 80 -j ACCEPT
сброс всех правил:
	iptables -F

^^
--@&--
^96 .
/&*/---ОС Linux---/&*/Ubuntu -- фильтрация пакетов/&*/ напишите пример конфигурации сервера/&*/
# разрешаем порт 22 для управления по SSH
iptables -A INPUT -p tcp --dropt=22 -j ACCEPT  # разрешили трафик по ssh подключению

iptables -A INPUT -p tcp -m miltiport --dropt 80,443 -j ACCEPT  # разрешить трафик через web браузеры протоколами HTTP HTTPS


iptables -A INPUT -i lo -j ACCEPT  # разрешить любо трафик внутри локального интерфейса

iptables -A INPUT -p icmp -j ACCEPT  # разрешить трафик пакетов icmp

iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT  # разрешаем входящие пакеты

iptables -P INPUT DROP  # запретить любой трафик , кроме указанного

^^
--@&--
^97 .
/&*/---ОС Linux---/&*/Ubuntu -- фильтрация пакетов/&*/ напишите команду для перенаправления портов/&*/

iptables -t nat -I PREROUTING -p tcp --dropt 80 -j REDIRECT --to-port 8080   # перенаправляет трафик http запросов на порт 8080

^^
--@&--
^98 .
/&*/---ОС Linux---/&*/Ubuntu -- фильтрация пакетов/&*/ как сохранить имеющуюся конфигурацию/&*/

iptables-save > ip.rules   # текущая конфигурация сохранится в выбранный нами файл
# при этом создаётся текстовый файл, который указывает настройки таблицы filter, при этом прямо в этом файле можно менять очередность всех правил
#..для достижения требуемых разрешений
^^
--@&--
^99 .
/&*/---ОС Linux---/&*/Ubuntu -- фильтрация пакетов/&*/ как применить конфигурацию, записанную в текстовом файле/&*/

команда:
	iptables-restore < ip.rules  # будет применена конфигурация, которая была в фале ip.rules 
^^
--@&--
^100 .
/&*/---ОС Linux---/&*/Ubuntu -- фильтрация пакетов/&*/ как сделать, чтобы настройки конфигурации автоматически сохранялись в файле и подгружались из него/&*/

необходимо установить утилиты: iptables-persistent   и   netfilter-persistent
команда:
	apt install iptables-persistent netfilter-persistent
# при установке iptables-persistent спросит возможность сохранить настройки в файл /etc/iptables/rules.v4 
#.. и далее при загрузке ОС эти правила будут автоматически загружаться оттуда
	
^^
--@&--
^101 .
/&*/---ОС Linux---/&*/Ubuntu -- фильтрация пакетов/&*/ как осуществить активацию (дезактивацию) межсетевого экрана (Firewall)/&*/
проверка статуса ufw:
команда:
	ufw status
необходимо применить команду:
	ufw enable   # активация межсетевого экрана
	ufw disable  # дезактивация межсетевого экрана
	
^^
--@&--
^102 .
/&*/---ОС Linux---/&*/Ubuntu -- фильтрация пакетов/&*/ Что делает утилита nslookup /&*/

синтаксис:
	nslookup  имя_домена

команда:
	nslookup ya.ru

результат:


Server:         127.0.0.53    # ответ с локального DNS сервера Ubuntu 
Address:        127.0.0.53#53

Non-authoritative answer:
Name:   ya.ru
Address: 5.255.255.242   # ip адрес сайта ya.ru
Name:   ya.ru
Address: 77.88.55.242
Name:   ya.ru
Address: 2a02:6b8::2:242
	
^^
--@&--
^103 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер на Linux/&*/ Опишите структуру HTTP запроса /&*/

GET /doc/test.html HTTP/1.1     # Request Line - запрос (GET - метод запроса, далее путь по которому мы хотим получить документ и версия протокола)
Host: www.test101.com    # заголовок, который определяет доменное имя 
Accept: image/gif, image/jpeg, */*  # заголовок, определяющий тип контента который можно дать в ответ
Accept-Language: en-us		# язык 
Accept-Encoding: gzip, deflate	#
User-Agent: Mozilla/4.0		#  версия браузера
Content-Length: 35	#  длина полукчаемого контента
--------------------------------------------- # пустые данные
дополнительные данные (могут быть, а может и не быть)     # тело запроса (как правило пустое, особенно для GET запросов)


^^
--@&--

^104 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер на Linux/&*/Опишите структуру HTTP ответа/&*/

HTTP/1.1 200 OK    # версия http протокола, код ответа (код ошибки или код статуса 2** - все хорошо запрос обработан, 3** - перенаправление браузера на другой адрес (Redirect)), 4** - ошибки клиента (запросили ресурс, его нет на сервере....), 5** - серверные ошибки (не работает база данных, перегрузка и так далее))
Date: Sat, 09 Oct 2010 14:28:02 GMT     # заголовки ответа
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
Etag: "51142bc1-7449-456777"
Accept-Ranges: bytes
Content-Lenght: 29769
Content-Type: text/html


^^
--@&--
^105 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер на Linux/&*/ Для чего нужны утилиты curl  и  wget /&*/

# Обе эти утилиты нужны, когда нет возможности запустить браузер, но нужно проверить работоспособность взаимодействия с сервером
# ..сделать это можно из консоли с помощью утилиты curl
синтаксис:
	curl -L https://имя_домена/
команда:
	curl -L https://ya.ru/
результат:
	<!doctype html><html prefix="og: http://ogp.me/ns#"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1"><title data-react-helmet="true">Ой!</title><meta data-react-helmet="true" 
property="og:title" content="Яндекс"><meta data-react-helmet="true" property="og:description" content="Найдётся всё"><meta data-react-helmet="true" 
property="og:image" content="https://yastatic.net/s3/home-static/_/37/37a02b5dc7a51abac55d8a5b6c865f0e.png"><link rel="stylesheet" href="/captcha_smart.0bfc4d9561e7e6e94795.min.c
........
# утилита wget как правило используется если надо что скачать

команда:
	wget https://yastatic.net/jquery/2.1.4/jquery.min.js
результат:

--2023-02-19 22:04:59--  https://yastatic.net/jquery/2.1.4/jquery.min.js
Распознаётся yastatic.net (yastatic.net)… 178.154.131.215, 178.154.131.216, 178.154.131.217, ...
Подключение к yastatic.net (yastatic.net)|178.154.131.215|:443... соединение установлено.
HTTP-запрос отправлен. Ожидание ответа… 200 OK
Длина: 84345 (82K) [application/x-javascript]
Сохранение в: ‘jquery.min.js’

jquery.min.js        100%[===================>]  82,37K  --.-KB/s    за 0,08s

2023-02-19 22:04:59 (985 KB/s) - ‘jquery.min.js’ сохранён [84345/84345]

^^
--@&--
^106 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер на Linux/&*/ Опишите схему работы https /&*/
1. Для соединения по https протоколу применяется порт 443 (вместо 80 у http)
2. Веб-браузер передает доменное имя на веб сервер (через которое нам нужно связаться с требуемым ресурсом
3. Веб сервер должен ответить сертификатом
4. Веб-браузер проверяет сертификат с использованием доверенных центров, список которых (Root CA) у нас установлен
# в сертификате указывается конкретное доменное имя, на которое выписан сертификат, дата действия (результат сравнения будет либо положительный либо нет и браузер выдаст в этом случае ошибку)
5. Если сертификат успешно проверен, то с веб сервером веб браузер устанавливает постоянный ключ шифрования
# ключ шифрования как правило симметричный (один и тот же для шифровки и для дешифровки)
6. После того, как ключ установлен организуется передача запросов - ответов между веб браузером и веб сервером уже в зашифрованном виде
7. Выдача сертификатов осуществляется удостоверяющими центрами (СА)
^^
--@&--
^107 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер Nginx/&*/ c помощью какой команды установить nginx и протестировать его конфигурацию /&*/
для установки nginx используется команда
	apt install nginx
для тестирования конфигурации:
	sudo nginx -t
результат:
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful


^^
--@&--
^108 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер Nginx/&*/ c помощью какой команды применить новую конфигурацию nginx /&*/
команда:

	sudo systemctl reload nginx

результат:



^^
--@&--
^109 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер Nginx/&*/где описывается конфигурация nginx /&*/
Конфигурация nginx описывается в файлах директории /etc/nginx/*
Основной файл конфигурации: /etc/nginx/nginx.conf
Он состоит:
	из блоков:   Имя_блока парметры_блока { директивы_блока }
	из директив: Имя_директивы параметры_директивы;   # точка с запятой обязательна
	из переменных:  $имя_переменной

^^
--@&--
^110 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер Nginx/&*/ проверка функционирования nginx /&*/
1. Набираем команду:
	sudo ss -ntlp    # для проверки статусов сокетов и видим сокет с 80 портом в режиме LISTEN и в списке процессов отображен nginx 
# 0.0.0.0:80   означает, что мы слушаем 80 порт на всех IP-адресах на всех интерфейсах
2. Проверяем работу веб сервера nginx по локальному интерфейсу 
	sudo curl localhost
Результат:
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
# то есть сервер работает и отвечает нам некоторой html страницей 	

3. Открываем главный конфигурационный файл /etc/nginx/nginx.conf c помощью любого редактора
важно, чтобы было указано имя пользователя
количество рабочих процессов
обязательно должна до начала всех блоков быть указана директива:
	include /etc/nginx/modules-enabled/*.conf;
далее в блоке events {} указано количество рабочих подключений
далее идет блок http {}  Это всё что относится к веб
	access_log  отвечает за любые запросы к серверу (пишет их)
	error_log   пишет все ошибки
4. После каждого изменения конфигурационного файла проверяем исправность конфигурации командной
	sudo nginx -t
5. Выполняем команду systemctl reload nginx, чтобы сделать рабочую конфигурацию

6. Выполняем команду ps afx   # список рабочих процессов
видим, что сеть на nginx есть

   3499 ?        S      0:00  \_ nginx: worker process
   3500 ?        S      0:00  \_ nginx: worker process
   3501 ?        S      0:00  \_ nginx: worker process
^^
--@&--
^111 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер Nginx/&*/ парные директории в nginx и для чего они нужны /&*/
Заметим, что в директории /etc/nginx/ имеются парные директории


modules-available/
modules-enabled/			

sites-available/
sites-enabled/      # если в неё зайти, то там увидим один файл в виде символической ссылки на sites-available  default -> /etc/nginx/sites-available/default
		    # зайдём в конфигурационный файл default (это наш основной сервер, который является сервером по умолчанию) и посмотрим, что там определено по умолчанию
команда:
	nano default
результат:
	server {
        listen 80 default_server;
        listen [::]:80 default_server;

        root /var/www/html;	# корневая директория, в которой будут находится файлы, которые запросили через curl

        index index.html index.htm index.nginx-debian.html;

        server_name _;		# здесь прописываем доменные имена для сервера по умолчанию для 80 порта, например site.ru  www.site.ru;
location / {
                
                try_files $uri $uri/ =404;  # отвечает за обработку запросов
        }
зайдём в директорию /var/www/html и убедимся, что там есть файл index.html
результат:
-rw-r--r-- 1 root root  612 лют  8 20:10 index.nginx-debian.html   # файл есть и название соответствует указанному в соответствующей директиве конфиг файла default



^^
--@&--

^112 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер Apache/&*/ основы /&*/

1. Способен работать с программным кодом (в отличие от nginx)
2. Установка с помощью команды:
	apt install apache2
3. Тестирование конфигурации:
	sudo apachectl -t
4. Применение конфигурации: sudo systemctl reload apache2
5. Конфигурация: /etc/apache2/*
6. Основной файл: /etc/apache2/apache2.conf
7. Синтаксис разметки блока <Название_блока> директивы </Название блока>
8. Синтаксис директив:  ServerName site.ru    # стиль CamelCase без точек с запятой, переном на новую строку


^^
--@&--

^113 .
/&*/---ОС Linux---/&*/Ubuntu -- Веб-сервер Apache/&*/ Установка работы веб сервера/&*/

Устанавливаем с помощью команды:
	apt install apache2
3. Тестирование конфигурации:
	sudo apachectl -t
Результат:
	AH00558: apache2: Could not reliably determine the server's fully qualified domain name, 
	using 127.0.1.1. Set the 'ServerName' directive globally to suppress this message
	Syntax OK  # в синтаксисе ошибок нет, но не может запуститься, так как веб сервер должен использовать по умолчанию порт 80, 
	..который сейчас занят веб сервером nginx
4. Пробуем принудительно запустить apache2:
	systemctl start apache2
Результат:
ob for apache2.service failed because the control process exited with error code.
See "systemctl status apache2.service" and "journalctl -xeu apache2.service" for details.
5. Выполняем команду:
	systemctl status apache2
Результат: увидим ошибку, указаывающую на то, что сокет с 80 портом уже занят
6. Заходим в директорию с конфигурацией и смотрим ее содержимое:
	cd /etc/apache2
	ls -la
Результат:
drwxr-xr-x   8 root root  4096 лют 20 00:00 .
drwxr-xr-x 135 root root 12288 лют 20 00:00 ..
-rw-r--r--   1 root root  7224 сту 23 21:34 apache2.conf    # основной конфиг файл
drwxr-xr-x   2 root root  4096 лют 20 00:00 conf-available  # директории, работающие по принципу символических ссылок (парные)
drwxr-xr-x   2 root root  4096 лют 20 00:00 conf-enabled
-rw-r--r--   1 root root  1782 вер  8 06:07 envvars
-rw-r--r--   1 root root 31063 вер  8 06:07 magic
drwxr-xr-x   2 root root 12288 лют 20 00:00 mods-available
drwxr-xr-x   2 root root  4096 лют 20 00:00 mods-enabled
-rw-r--r--   1 root root   320 вер  8 06:07 ports.conf    # нужен для настройки портов
drwxr-xr-x   2 root root  4096 лют 20 00:00 sites-available
drwxr-xr-x   2 root root  4096 лют 20 00:00 sites-enabled
7.Зайдём в файл portS.conf
	Команда: nano ports.conf
	Результат:
Listen 80     # эту директиву необходимо поменять на 8080 (альтернативный порт)

<IfModule ssl_module>
        Listen 443   # при наличии ssl Модуля автоматически подключится порт 443 
</IfModule>

<IfModule mod_gnutls.c>
        Listen 443
</IfModule>

Изменяем прослушиваемый порт на 8080 сохраняем, выходим и запускаем тестирование конфигурации apachectl -t
Результат:
AH00558: apache2: Could not reliably determine the server's fully qualified domain name, 
using 127.0.1.1. Set the 'ServerName' directive globally to suppress this message
Syntax OK  # самое главное что с синтаксисом все в порядке и пропала ошибка о невозможности запуститься 	

8. Далее запускаем apache
	Команда:  
	systemctl start apache2 
9. Проверка командой ss -ntlp   показывает, что apache слушает порт 8080
Результат:
LISTEN  0     511     *:8080      *:*     users:(("apache2",pid=4330,fd=4),("apache2",pid=4329,fd=4),("apache2",pid=4328,fd=4))
10. Также можно проверить командой systemctl status apache2
Результат:

● apache2.service - The Apache HTTP Server
     Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2023-02-20 00:25:37 +03; 2min 40s ago
       Docs: https://httpd.apache.org/docs/2.4/
    Process: 4324 ExecStart=/usr/sbin/apachectl start (code=exited, status=0/SUCCESS)
   Main PID: 4328 (apache2)
      Tasks: 55 (limit: 2287)
     Memory: 5.1M
        CPU: 38ms
     CGroup: /system.slice/apache2.service
             ├─4328 /usr/sbin/apache2 -k start
             ├─4329 /usr/sbin/apache2 -k start
             └─4330 /usr/sbin/apache2 -k start

лют 20 00:25:37 valeentin87-VirtualBox systemd[1]: Starting The Apache HTTP Server...
лют 20 00:25:37 valeentin87-VirtualBox apachectl[4327]: AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1. Set the 'ServerName' directive globally to suppress this message
лют 20 00:25:37 valeentin87-VirtualBox systemd[1]: Started The Apache HTTP Server.

10. Для полноты конфигурации проверим, что сайт по умолчанию, прописанный в конфиг директории sites-enabled будет привязан к порту 8080
заходим в директорию sites-enabled и видим, что там единственный файл 000-default.conf 
запускаем его в редакторе nano и меняем порт 80 на 8080 (сокет к которому будет принадлежать) с
сохраняем, выходим и тестируем конфигурацию apachectl -t
11. делаем reload нашего сервера:
	команда:	
		systemctl reload apache2
12. Проверяем работоспособность сервера apache2 через команду curl
	curl localhost:8080
Результат:
	Получим довольно-таки большую html страницу

13. Теперь если перейтив директорию /var/www/html то увидим наличие большого файла
	index.html который мы загрузили
root@valeentin87-VirtualBox:/etc/apache2/sites-enabled# cd /var/www/html
root@valeentin87-VirtualBox:/var/www/html# ls -la
итого 24
drwxr-xr-x 2 root root  4096 лют 20 00:00 .
drwxr-xr-x 3 root root  4096 лют  8 20:10 ..
-rw-r--r-- 1 root root 10671 лют 20 00:00 index.html   # загруженный файл
-rw-r--r-- 1 root root   612 лют  8 20:10 index.nginx-debian.html
^^
--@&--
^114 .
/&*/---ОС Linux---/&*/Ubuntu -- Настройка прокси сервера/&*/Как работает схема Reverse proxy/&*/
1. Веб-браузер:
	выполняет клиентский код
	отображает интерфейс
2. Nginx (frontend)
	обрабатывает соединения
	отдаёт статику (CSS, JS, картинки)
	проксирует дитнамические запросы
3. Apache (backend)
	обрабатывает динамические запросы
	исполняет серверный код (PHP, Perl, Python)
	возвращает ответ Nginx

4. Заходим в браузер, включаем инструмент разработчика, заходим во вкладку Network,включаем фильтр doc (html документы которые мы смотрим)
	как правило всё, что лежит во вкладке doc это результаты динамических запросов
	во вкладке img с большой степенью вероятности это результаты статических запросов
^^
--@&--
^115 .
/&*/---ОС Linux---/&*/Ubuntu -- Настройка прокси сервера/&*/ Пример конфигурации Nginx для Reverse proxy для/&*/

# Динамические запросы
location / {
	proxy_pass http://localhost:8080; # главная директива, которая реализует Reverse proxy, делает запрос к очередному веб серверу в цепочке 
	proxy_set_header Host $host;	  # данные заголовки позволяют понять с какого домена, какие свойства с какого IP пришёл ответ
	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	proxy_set_header X-Real-IP $remote_addr;
}
# Apache обработает запрос, вернёт его nginx а тот клиенту
# статические запросы
location ~* ^.+.(jpg|jpeg|gif|png|ico|css|zip|pdf|txt|tar|js)$ {    # перехватывает статические запросы 
# ~* Означает что использует регулярные выражения
# ^.+.  это шаблон под который должен попадать запрос (в скобках перечислены расширения файлов, которые будут относиться к статическим запросам)
	root /var/www/html;  # здесь будут искаться эти файлы, если они есть их отдаём, если нет выдаем ошибку
}

# любой блок с регулярным выражением имеет приоритет (рассматривается сначала)

^^
--@&--
^116 .
/&*/---ОС Linux---/&*/Ubuntu -- Настройка прокси сервера/&*/ Как осуществить проброс портов для веб сервера/&*/

1. Заходим в настройки сети в Virtual box
2. В случае типа подключения NAT добавляем проброс портов 
3. Добавляем порт хоста (9080) и порт гостя (80)  - это будет Nginx
4. Нажимаем OK и сохраняем настройки
Теперь если набрать в браузере localhost:9080 мы увидим что нам откликнется веб-сервер nginx
Результат:
Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.

For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.

Thank you for using nginx.
5. Заходим в директорию конфигурации /etc/nginx/sites-enabled и просматриваем файл default
	удаляем блок location / {
		try_files $uri $uri/ =404
}

6. Добавляем конфигурацию, которая нужна для схемы reverse  proxy
добавляем три location (для перенаправления apache, для обработки кода, и для обработки статики) причём статический пока закомментируем, чтобы всё уходило гарантировано на apache
7. Сохраняем выходим
8. Тестируем конфигурацию. nginx -t
9. Делаем systemctl reload nginx
^^
--@&--
^117 .
/&*/---ОС Linux---/&*/Ubuntu -- Настройка прокси сервера/&*/ Как настроить модуль для работы с PHP на стороне apache/&*/

1. Устанавливаем модуль libapache2-mod-php8.1  и сам интерпретатор php8.1
	apt install libapache2-mod-php8.1 php8.1
2. Заходим в директорию конфигураций apache2  mods-enable
просматриваем список файлов, которые в нём имеются
файл конфигурации модуля рhp8.1
lrwxrwxrwx 1 root root   29 лют 20 02:05 php8.1.conf -> ../mods-available/php8.1.conf
Открываем его с помощью cat
Результат:
<FilesMatch ".+\.ph(ar|p|tml)$">
    SetHandler application/x-httpd-php  # данная директива позволяет открывать файлы php как приложения
</FilesMatch>
<FilesMatch ".+\.phps$">
    SetHandler application/x-httpd-php-source
    # Deny access to raw php sources by default
    # To re-enable it's recommended to enable access to the files
    # only in specific virtual host or directory
    Require all denied
</FilesMatch>
# Deny access to files without filename (e.g. '.php')
<FilesMatch "^\.ph(ar|p|ps|tml)$">
    Require all denied
</FilesMatch>

# Running PHP scripts in user directories is disabled sby default
#
# To re-enable PHP in user directories comment the following lines
# (from <IfModule ...> to </IfModule>.) Do NOT set it to On as it
# prevents .htaccess files from disabling it.
<IfModule mod_userdir.c>
    <Directory /home/*/public_html>
        php_admin_flag engine Off
    </Directory>
</IfModule>

# причём сам модуль уже подключен
3. Создаём тестовый файл с расширением php
4. Переходим в директорию /var/www/html и создаём файл info.php
в который заносим и сохраняем 
<?php
phpinfo();
?>
5. Теперь в браузере переходим по адресу localhost:9080/info.php
^^
--@&--
^118 .
/&*/---ОС Linux---/&*/Ubuntu -- Настройка прокси сервера/&*/Пример конфигурации Nginx для Reverse proxy для/&*/


# Динамические запросы
location / {
	proxy_pass http://localhost:8080; # главная директива, которая реализует Reverse proxy, делает запрос к очередному веб серверу в цепочке 
	proxy_set_header Host $host;	  # данные заголовки позволяют понять с какого домена, какие свойства с какого IP пришёл ответ
	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	proxy_set_header X-Real-IP $remote_addr;
}
# Apache обработает запрос, вернёт его nginx а тот клиенту
# статические запросы
location ~* ^.+.(jpg|jpeg|gif|png|ico|css|zip|pdf|txt|tar|js)$ {    # перехватывает статические запросы 
# ~* Означает что использует регулярные выражения
# ^.+.  это шаблон под который должен попадать запрос (в скобках перечислены расширения файлов, которые будут относиться к статическим запросам)
	root /var/www/html;  # здесь будут искаться эти файлы, если они есть их отдаём, если нет выдаем ошибку
}

# любой блок с регулярным выражением имеет приоритет (рассматривается сначала)

^^
--@&--


^119 .

/&*/---ОС Linux---/&*/Ubuntu -- Настройка прокси сервера Nginx Apache/&*/ Как настроить модуль для работы с PHP на стороне apache/&*/

1. Обновляем список пакетов:
	sudo apt-get update
2. Ставим apache2 и опционально модуль для работы с заголовками (X-Forwarded-For):
	sudo apt-get install apache2 libapache2-mod-rpaf
3. Apache2 сейчас слушает на 80 порту
	ss -ntlp
Результат:
LISTEN  0   511  *:80   *:*   users:(("apache2",pid=44418,fd=4),("apache2",pid=44417,fd=4),("apache2",pid=44416,fd=4))
4. Заходим в FireFox И переходим на localhost
Результат: Приветственное окно Apache сервера
5. Поставим curl
	sudo apt install curl
6. Проверим:
	curl -I http://localhost
Результат запроса:
HTTP/1.1 200 OK
Date: Mon, 20 Feb 2023 09:35:38 GMT
Server: Apache/2.4.52 (Ubuntu)
Last-Modified: Mon, 20 Feb 2023 09:22:23 GMT
ETag: "29af-5f51e3369ad7f"
Accept-Ranges: bytes
Content-Length: 10671
Vary: Accept-Encoding
Content-Type: text/html
7. Перенастроим apache2 чтобы он слушал другой файл Посмотрим файл ports.conf
	sudo nano /etc/apache2/ports.conf   # поменяем порт с 80 на 8000 и сохраним
8. Перезапишем конфигурацию apache2
	systemctl reload apache2
9. Теперь через команду 
	ss -ntlp   # видим что apache2 слушает порт 8000
10. Теперь изменим установки нужного сайта
	nano /etc/apache2/sites-available/000-default.conf

	<VirtualHost *:80> на 127.0.0.1:8000   # опять делаем reload 
11. Перезапускаем сервер apache2:
	sudo service apache2 restart
12. Ставим nginx:
	sudo apt-get install  nginx
13. Выполняем команду 
	netstat -ant   # и убеждаемся, что nginx не запущен, так как требует конфигурирования
14. Запускаем сервер nginx
	sudo service nginx start
Теперь командами curl -I http://localhost   И curl -I http://localhost:8000 можно убедиться что на разных портах apace2 и nginx

15. Переходим в директорию /etc/nginx/sites-available/
сохраняем файл default под новым именем как оригинальный
	sudo cp -v 000-default.conf default_orig.conf
Результат:
'000-default.conf' -> 'default_orig.conf'

16. Запускаем файл default для редактирования
	указываем настройки прокси:
		
		proxy_pass http://localhost:8000/;
                proxy_redirect off;
                include /etc/nginx/proxy_params;
 и имя сайта server_name www.site_valeentin87.ru;
сохраняем и делаем reload
17. Перезапускаем сервер nginx
	sudo service nginx restart
18. Теперь в браузере на стандартном порту мы видим apache2, но отвечает нам nginx
	curl -I http://localhost

^^
--@&--
^120 .
/&*/---ОС Linux---/&*/Ubuntu -- Настройка прокси сервера/&*/ Установка MySQL и создание таблицы/&*/

1. Выпорняем команду:
	apt install mysql-server-8.0

2. Заходим в консоль MySQL: sudo mysql

3. Определяем себя как отдельного пользователя и пароля (поскольку заходим в СУБД от имени рута то пароль не обязателен)

4. С помощью команды ps afx видим, что запущен процесс
8355 ?        Ssl    0:02 /usr/sbin/mysqld  # (сервер mysql)

5. C помощью команды sudo ss -tulpan   
находим активное подключение по порту 3306 и 3360 
tcp   LISTEN   0     151       127.0.0.1:3306      0.0.0.0:*    users:(("mysqld",pid=8355,fd=23))
причём он слушает не все адрес а только localhost (127.0.0.1)
6. После выполнения команды sudo mysql мы попадаем в консоль mysql
о чем говорит приглашение

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 9
Server version: 8.0.32-0ubuntu0.22.04.2 (Ubuntu)

7. Посмотреть имеющиеся ,базы данных
	show databases;
Результат:

+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0,00 sec)

# Это системные стандартные базы данных

8. Чтоб зайти в базу данных:
	use назв_базы_данных;
9. Чтоб просмотреть имеющиеся таблицы используют команду 
	show tables;
Результат:
+------------------------------------------------------+
| Tables_in_mysql                                      |
+------------------------------------------------------+
| columns_priv                                         |
| component                                            |
| db                                                   |
| default_roles                                        |
| engine_cost                                          |
....................

10. Отобразим всю информацию по таблице user
	SELECT * FROM user;
# в результате получим нечиатемую таблицу, чтобы это исправить используем команду
	SELECT * FROM user\G

Результат удобный для терминала:
выводится каждая строчка а далее на каждой новой строке данные колонки
*************************** 5. row ***************************
             Host: localhost
             User: root
             Select_priv: Y
             Insert_priv: Y
             Update_priv: Y
^^
--@&--

^121 .
/&*/---ОС Linux---/&*/Ubuntu -- Скрипты bash/&*/
Bash    -    язык программирования
Интерпретатор  /bin/bash
exit code    - код завершения (код ошибки), если 0 - ошибки не было, иначе - была ошибка

echo $?    # вывод кода завершения последней командым  $ - знак переменной  '?' - название переменной
результат:
	0   # ошибок нет

STDIN (0)   # стандартный поток ввода  (как правило клавиатурва)
STDOUT (1)  # стандартный поток вывода (1 - поток вывода на экран терминала, файл...)
STDERR (2)  # стандартный поток ошибок


program  < file   - перенаправление потока ввода из файла
program  > file   - перенаправление потока вывода (STDOUT) в файл (запись с начала файла)
program  >> file   - перенаправление потока вывода (STDOUT) в файл (дозапись файла)
program  2> file   - перенаправление потока ошибок (STDERR) в файл (запись с начала файла)
program  2>> file   - перенаправление потока ошибок (STDERR) в файл (дозапись файла)
program > file 2 > &1  - перенаправление вывода (STDOUT) и ошибок (STDERR) в файл file (запись с начала файла)

------------------------
Команда: ls > ls.txt	# перенаправим поток вывода в файл ls.txt
Команда: cat ls.txt
Результат:
dir1
file2_rename
file3
file4_rename
ls.txt
my_file
my_file_dublicat
newdir
newtextfile
newtextfile1
seminar3linux
----------------------------
Команда: ls >> ls.txt	# перенаправим поток вывода в файл ls.txt с дозаписью файла
Команда: cat ls.txt
Результат:
dir1
file2_rename
file3
file4_rename
ls.txt
my_file
my_file_dublicat
newdir
newtextfile
newtextfile1
seminar3linux
dir1
file2_rename
file3
file4_rename
ls.txt
my_file
my_file_dublicat
newdir
newtextfile
newtextfile1
seminar3linux-
------------------------------
Команда:
	cat /swapfile 2> err.txt   # попытались просмотреть содержимое файла, к которому у нас нет доступа и записали результат ошибок в файл
Команда:
valeentin87@valeentin87-VirtualBox:~$ cat err.txt
Результат:
cat: /swapfile: Отказано в доступе
------------------------------
Команда:
	cat newtextfile /swapfile > allresult.txt 2>&1   # вывели в один файл результаты потока вывода и результаты ошибок
Команда:
	cat allresult.txt
Результат:
edlklfkvflvklkvlv
fgghgtht
rggrgr
cat: /swapfile: Отказано в доступе
-------------Конвейер (pipeline, pipe)---------------
Перенаправление ввода-вывода между процессами

ls -al | grep file

ls -al | grep -P '\.[cs]+'

cat /var/log/syslog | grep 'mysql' | grep -v 'file' | wc -l

В конвеере выходные данные одной команды (до |) являются входными данными (после |) для следующей команды, данные как бы поэтапно фильтруются и выполняется одна большая комплексаная задача
| grep file    # фильтровать по наличию слова
| grep -v file  #все данные, имеющие слово file удалить
| grep -i 'sqlite'    # найти все данные, где независимо от регистра встречается слово sqlite
| wc   -l    # посчитать количество строк
| sort    # сортировка данных
-------------Переменные и их классификация---------------
Переменные окружения  # верхний регистр, как правило неизменяемые, системные
$PATH

$UID

$RWD

Пользовательские переменные

var1=test

echo $var1    #вывод в консоль переменной var1

Специальные переменные

$1...$9

$?
--------переменные окружения-----------
Команда:
	printenv    # выводит в консоль значения переменных окружения
Результат:

SHELL=/bin/bash
LC_ADDRESS=be_BY.UTF-8
LC_NAME=be_BY.UTF-8
LC_MONETARY=be_BY.UTF-8
PWD=/home/valeentin87
LOGNAME=valeentin87

Команда:
	echo $PWD
Результат:
/var/log    #покажет текущую директорию

Команда:
	echo $OLDPWD
Результат:
/home/db    #покажет предыдущую директорию
----------пользовательские переменные--------------
Команда:
	var1=test     #строчка test присваивается переменной var1
# когда значение в переменную записывается знак $ не ставится, когда читается значение из переменной то $ ставится
Команда:
	echo $var1
Результат:
	test
# Переменные видны только в текущей сессии оболочки (если создавать вложенную допустим командой bash, то про нашу переменную var1 она ничего знать не будет
# Переменные живут только до момента выхода из сессии (закрытия терминала)
# если нужно переменной присвоить несколько слов с пробелами, необходимо значение обрамить одинарными кавычками
Команда:
	var1='Etegh dfkeld doefjfkle ede j'
# Чтобы в переменную поместить значения других переменных используют интерполяцию
Команда:
	var3="$var1 $var2"   # переменной var3 будет присвоено значение перенменной var1 var2 через пробел
#чтобы переменной присвоить значение допустим списка всех файлов используют следующий синтаксис:
Команда:
	var_ls=$(ls -al)
Команда:
	echo $var_ls
Результат:
	итого 428 drwxr-x--- 24 valeentin87 cdrom 4096 лют 24 19:00 . drwxr-xr-x 6 root root
 4096 лют 5 19:07 .. -rw-r--r-- 1 valeentin87 cdrom 85 лют 24 19:00 allresult.txt -rw------- 
1 valeentin87 cdrom 6899 лют 24 13:22 .bash_history -rw-r--r-- 1 valeentin87 cdrom 220 сту 30 
21:26 .bash_logout -rw-r--r-- 1 valeentin87 cdrom 3771 сту 30 21:26 .bashrc drwx------ 13 valeentin87 
cdrom 4096 сту 31 00:07 .cache drwx------ 14 valeentin87 cdrom 4096 лют 3 14:32 .config drwxrwxr-x 4 
valeentin87 cdrom 4096 лют 2 21:19 dir1 -rw-r--r-- 1 valeentin87 cdrom 51 лют 24 18:53 err.txt -rw-rw-r-- 
1 valeentin87 cdrom 84 лют 4 18:57 file2_rename lrwxrwxrwx 1 valeentin87 cdrom 23 лют 4 18:59 file3 -> 
/home/valeentin87/file1 -rw-rw-r-- 1 valeentin87 cdrom 84 лют 4 18:55 fi
# переменной var_ls в одну строчку присвоено значение списка

#конструкцию $(ls -al)  можно заменить бэк тиками `ls -al`  результат будет таким же

---------------первый скрипт-------------------
любой скрипт начинаетс с шбэнк строчки, который состоит из # ! пути к интерпретатору
#!/bin/bash	- шбэнк строчка определяет интерпретатор, который будет выполнять нижеописанный скрипт

1. Создаём файл в любом текстовом редакторе, допустим с консоли с именем testsc
Команда:
	cat > testsc
2. Далее записываем в него непосредственно текст скрипта
#!/bin/bash

# Первый скрипт

directory=$1  # установили переменную. В переменную directory мы передаём путь к директории 
hidden_count=$(ls -A $directory | grep '^\.' | wc -l) # в переменную hidden_count будет записан результат работы конвейера по подсчёту количества строк, которые в указанной директории начинаются с . (скрытые файлы)

# вывести значение переменной
echo "Hidden files in $directory found: $hidden_count"
	

-------------запуск скриптов-----------------
для запуска скриптов из текущей директории можно использовать команды:
Относительный путь   ./testscript
Абсолютный путь:   /home/db/test/testscript
Команда (должен быть в $PATH): testscript  # ПУТЬ К ИСПОЛНЯЕМОМУ ФАЙЛУ ДОЛЖЕН БЫТЬ УКАЗАН В ПЕРЕМЕННОЙ $PATH
Через команду bash:  bash testscript
Первые три варианта требуют шебанг и права на исполнение

# если выполнить команду:
	echo $PATH
Результат:
	/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
будут по очереди проверены все директории с иполняемыми файлами (через :) слева направо и будет выполнена первая скрипт которой будет найден.

#Запуск по относительному пути:
Команда:
	./testsc
Результат:
	Отказано в доступе
# потому что нет прав на исполнение
-rw-r--r--  1 valeentin87 cdrom       639 лют 24 20:22  testsc
# Добавляем нашему скрипту бит на исполнение:
	Команда:
		chmod +x testsc
Результат:
	4 -rwxr-xr-x 1 valeentin87 cdrom       639 лют 24 20:22  testsc
# теперь запуск скрипта прошёл успешно:
Результат:
	Hidden files in  found: 15
# чтобы запустить тот же самый скрипт но уже для подсчёта не в домашней директории и а в конкретной укажем через пробел путь к директории в которой нужно произвести подсчёт
Команда:
	./testsc /etc
Результат:
	Hidden files in /etc found: 1
# запуск по абсолютному пути:
Команда:
	/home/valeentin87/testsc
Результат:
	Hidden files in  found: 15
Причём команда bash testsc не требует прав на исполнение
---------------------однострочные скрипты------------------------
Разделитель команд ;
Удобны для выполнения в терминале
Применимы все конструкции из bash
Допустим пример:
	apt update; apt upgrade; echo "Upgrade complete!"
---------------условия if и ветвления--------------------
Синтаксис:
if [ выражение ]
     then
	 Действия, если выражение истинно
     else
	 Действия в противоположном случае
fi

Пример:

if [ -e file_name ]  # должны быть пробелы вокруг квадратных скобок
     then
	 echo "true"
     else
	 echo "false"
fi

Операции сравнения строк (наиболее используемые):
● = или == возвращает true (истина), если строки равны;
● != возвращает true (истина), если строки не равны;
● -z возвращает true (истина), если строка пуста;
● -n возвращает true (истина), если строка не пуста

чтобы посмотреть справку по ветвлениям (условиям) команда man test	

-----------------циклы--------------------
for имя_переменной in значения
do
тело_цикла
done

Цикл while выполняется до тех пор, пока условие истинно. Структура цикла:
while [ условие ]
do
Тело_цикла
done

	



	